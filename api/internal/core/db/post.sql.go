// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: post.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addPostToFriendGroup = `-- name: AddPostToFriendGroup :exec
INSERT INTO friend_group_posts (
    group_id,
    post_id
) VALUES (
    $1, $2
)
`

type AddPostToFriendGroupParams struct {
	GroupID uuid.UUID `json:"groupId"`
	PostID  uuid.UUID `json:"postId"`
}

func (q *Queries) AddPostToFriendGroup(ctx context.Context, arg AddPostToFriendGroupParams) error {
	_, err := q.db.Exec(ctx, addPostToFriendGroup, arg.GroupID, arg.PostID)
	return err
}

const checkPostOwner = `-- name: CheckPostOwner :one
SELECT EXISTS(SELECT 1 FROM posts WHERE user_id = $1 and id = $2)
`

type CheckPostOwnerParams struct {
	UserID uuid.UUID `json:"userId"`
	ID     uuid.UUID `json:"id"`
}

func (q *Queries) CheckPostOwner(ctx context.Context, arg CheckPostOwnerParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkPostOwner, arg.UserID, arg.ID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserMemberOfPostGroups = `-- name: CheckUserMemberOfPostGroups :one
SELECT EXISTS (
    SELECT 1
    FROM friend_group_members
    JOIN friend_group_posts ON friend_group_members.group_id = friend_group_posts.group_id
    WHERE friend_group_members.user_id = $1
      AND friend_group_posts.post_id = $2
    LIMIT 1
)
`

type CheckUserMemberOfPostGroupsParams struct {
	UserID uuid.UUID `json:"userId"`
	PostID uuid.UUID `json:"postId"`
}

func (q *Queries) CheckUserMemberOfPostGroups(ctx context.Context, arg CheckUserMemberOfPostGroupsParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserMemberOfPostGroups, arg.UserID, arg.PostID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
    id, user_id, media, date_created, caption
) VALUES (
    $1, $2, $3, $4, $5
)
ON CONFLICT (id) DO NOTHING
RETURNING id, user_id, media, date_created, caption
`

type CreatePostParams struct {
	ID          uuid.UUID          `json:"id"`
	UserID      uuid.UUID          `json:"userId"`
	Media       MediaType          `json:"media"`
	DateCreated pgtype.Timestamptz `json:"dateCreated"`
	Caption     *string            `json:"caption"`
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.ID,
		arg.UserID,
		arg.Media,
		arg.DateCreated,
		arg.Caption,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Media,
		&i.DateCreated,
		&i.Caption,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts
WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePost, id)
	return err
}

const getPost = `-- name: GetPost :one
SELECT id, user_id, media, date_created, caption FROM posts
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetPost(ctx context.Context, id uuid.UUID) (Post, error) {
	row := q.db.QueryRow(ctx, getPost, id)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Media,
		&i.DateCreated,
		&i.Caption,
	)
	return i, err
}

const getPostScore = `-- name: GetPostScore :one
SELECT score
FROM friend_group_posts
WHERE group_id = $1
  AND post_id = $2
`

type GetPostScoreParams struct {
	GroupID uuid.UUID `json:"groupId"`
	PostID  uuid.UUID `json:"postId"`
}

func (q *Queries) GetPostScore(ctx context.Context, arg GetPostScoreParams) (pgtype.Numeric, error) {
	row := q.db.QueryRow(ctx, getPostScore, arg.GroupID, arg.PostID)
	var score pgtype.Numeric
	err := row.Scan(&score)
	return score, err
}

const getPosts = `-- name: GetPosts :many
SELECT id, user_id, media, date_created, caption FROM posts
ORDER BY date_created
`

func (q *Queries) GetPosts(ctx context.Context) ([]Post, error) {
	rows, err := q.db.Query(ctx, getPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Media,
			&i.DateCreated,
			&i.Caption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTopPost = `-- name: GetTopPost :one
SELECT posts.id, posts.user_id, posts.media, posts.date_created, posts.caption
FROM friend_group_posts fgp
JOIN posts on fgp.post_id = posts.id
WHERE fgp.group_id = $1
ORDER BY fgp.score DESC
LIMIT 1
`

type GetTopPostRow struct {
	Post Post `json:"post"`
}

func (q *Queries) GetTopPost(ctx context.Context, groupID uuid.UUID) (GetTopPostRow, error) {
	row := q.db.QueryRow(ctx, getTopPost, groupID)
	var i GetTopPostRow
	err := row.Scan(
		&i.Post.ID,
		&i.Post.UserID,
		&i.Post.Media,
		&i.Post.DateCreated,
		&i.Post.Caption,
	)
	return i, err
}

const listPaginatedPostsForGroup = `-- name: ListPaginatedPostsForGroup :many
SELECT posts.id, posts.user_id, posts.media, posts.date_created, posts.caption
FROM friend_group_posts fgp
JOIN posts ON posts.id = fgp.post_id
WHERE fgp.group_id = $1
  AND (fgp.score, fgp.post_id) < ($2, $3::uuid)
ORDER BY fgp.score DESC, fgp.post_id DESC
LIMIT $4
`

type ListPaginatedPostsForGroupParams struct {
	GroupID uuid.UUID      `json:"groupId"`
	Score   pgtype.Numeric `json:"score"`
	Column3 uuid.UUID      `json:"column3"`
	Limit   int32          `json:"limit"`
}

type ListPaginatedPostsForGroupRow struct {
	Post Post `json:"post"`
}

func (q *Queries) ListPaginatedPostsForGroup(ctx context.Context, arg ListPaginatedPostsForGroupParams) ([]ListPaginatedPostsForGroupRow, error) {
	rows, err := q.db.Query(ctx, listPaginatedPostsForGroup,
		arg.GroupID,
		arg.Score,
		arg.Column3,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPaginatedPostsForGroupRow
	for rows.Next() {
		var i ListPaginatedPostsForGroupRow
		if err := rows.Scan(
			&i.Post.ID,
			&i.Post.UserID,
			&i.Post.Media,
			&i.Post.DateCreated,
			&i.Post.Caption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPostsForGroup = `-- name: ListPostsForGroup :many
SELECT posts.id, posts.user_id, posts.media, posts.date_created, posts.caption
FROM friend_group_posts
JOIN posts ON friend_group_posts.post_id = posts.id
WHERE friend_group_posts.group_id = $1
`

type ListPostsForGroupRow struct {
	Post Post `json:"post"`
}

func (q *Queries) ListPostsForGroup(ctx context.Context, groupID uuid.UUID) ([]ListPostsForGroupRow, error) {
	rows, err := q.db.Query(ctx, listPostsForGroup, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsForGroupRow
	for rows.Next() {
		var i ListPostsForGroupRow
		if err := rows.Scan(
			&i.Post.ID,
			&i.Post.UserID,
			&i.Post.Media,
			&i.Post.DateCreated,
			&i.Post.Caption,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removePostFromFriendGroup = `-- name: RemovePostFromFriendGroup :exec
DELETE FROM friend_group_posts
WHERE group_id = $1
  AND post_id = $2
`

type RemovePostFromFriendGroupParams struct {
	GroupID uuid.UUID `json:"groupId"`
	PostID  uuid.UUID `json:"postId"`
}

func (q *Queries) RemovePostFromFriendGroup(ctx context.Context, arg RemovePostFromFriendGroupParams) error {
	_, err := q.db.Exec(ctx, removePostFromFriendGroup, arg.GroupID, arg.PostID)
	return err
}

const updatePost = `-- name: UpdatePost :exec
UPDATE posts
SET media = $2,
    date_created = $3,
    caption = $4
WHERE id = $1
`

type UpdatePostParams struct {
	ID          uuid.UUID          `json:"id"`
	Media       MediaType          `json:"media"`
	DateCreated pgtype.Timestamptz `json:"dateCreated"`
	Caption     *string            `json:"caption"`
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) error {
	_, err := q.db.Exec(ctx, updatePost,
		arg.ID,
		arg.Media,
		arg.DateCreated,
		arg.Caption,
	)
	return err
}

const updatePostScore = `-- name: UpdatePostScore :exec
UPDATE friend_group_posts
SET score = $2
WHERE post_id = $1
`

type UpdatePostScoreParams struct {
	PostID uuid.UUID      `json:"postId"`
	Score  pgtype.Numeric `json:"score"`
}

func (q *Queries) UpdatePostScore(ctx context.Context, arg UpdatePostScoreParams) error {
	_, err := q.db.Exec(ctx, updatePostScore, arg.PostID, arg.Score)
	return err
}
