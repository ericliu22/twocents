// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: group.sql

package database

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToGroup = `-- name: AddUserToGroup :one
INSERT INTO friend_group_members (
    group_id,
    user_id,
    joined_at,
    role
) VALUES (
    $1, $2, $3, $4
)
RETURNING group_id, user_id, joined_at, role
`

type AddUserToGroupParams struct {
	GroupID  uuid.UUID          `json:"groupId"`
	UserID   uuid.UUID          `json:"userId"`
	JoinedAt pgtype.Timestamptz `json:"joinedAt"`
	Role     GroupRole          `json:"role"`
}

func (q *Queries) AddUserToGroup(ctx context.Context, arg AddUserToGroupParams) (FriendGroupMember, error) {
	row := q.db.QueryRow(ctx, addUserToGroup,
		arg.GroupID,
		arg.UserID,
		arg.JoinedAt,
		arg.Role,
	)
	var i FriendGroupMember
	err := row.Scan(
		&i.GroupID,
		&i.UserID,
		&i.JoinedAt,
		&i.Role,
	)
	return i, err
}

const checkUserMembership = `-- name: CheckUserMembership :one

SELECT EXISTS(SELECT 1 FROM friend_group_members WHERE group_id = $1 and user_id = $2)
`

type CheckUserMembershipParams struct {
	GroupID uuid.UUID `json:"groupId"`
	UserID  uuid.UUID `json:"userId"`
}

// optional
func (q *Queries) CheckUserMembership(ctx context.Context, arg CheckUserMembershipParams) (bool, error) {
	row := q.db.QueryRow(ctx, checkUserMembership, arg.GroupID, arg.UserID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkUserMembershipForGroups = `-- name: CheckUserMembershipForGroups :many
WITH input_groups AS (
    SELECT UNNEST($2::uuid[]) AS group_id
)
SELECT
    ig.group_id::uuid         AS "group_id",
    (fgm.group_id IS NOT NULL)::boolean AS "is_member"
FROM input_groups ig
LEFT JOIN friend_group_members fgm
       ON ig.group_id = fgm.group_id
      AND fgm.user_id = $1
ORDER BY ig.group_id
`

type CheckUserMembershipForGroupsParams struct {
	UserID  uuid.UUID   `json:"userId"`
	Column2 []uuid.UUID `json:"column2"`
}

type CheckUserMembershipForGroupsRow struct {
	GroupID  uuid.UUID `json:"groupId"`
	IsMember bool      `json:"isMember"`
}

func (q *Queries) CheckUserMembershipForGroups(ctx context.Context, arg CheckUserMembershipForGroupsParams) ([]CheckUserMembershipForGroupsRow, error) {
	rows, err := q.db.Query(ctx, checkUserMembershipForGroups, arg.UserID, arg.Column2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CheckUserMembershipForGroupsRow
	for rows.Next() {
		var i CheckUserMembershipForGroupsRow
		if err := rows.Scan(&i.GroupID, &i.IsMember); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const createFriendGroup = `-- name: CreateFriendGroup :one
INSERT INTO friend_groups (
    id,
    name,
    date_created,
    owner_id
) VALUES (
    $1, $2, $3, $4
)
RETURNING id, name, date_created, owner_id
`

type CreateFriendGroupParams struct {
	ID          uuid.UUID          `json:"id"`
	Name        string             `json:"name"`
	DateCreated pgtype.Timestamptz `json:"dateCreated"`
	OwnerID     uuid.UUID          `json:"ownerId"`
}

func (q *Queries) CreateFriendGroup(ctx context.Context, arg CreateFriendGroupParams) (FriendGroup, error) {
	row := q.db.QueryRow(ctx, createFriendGroup,
		arg.ID,
		arg.Name,
		arg.DateCreated,
		arg.OwnerID,
	)
	var i FriendGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DateCreated,
		&i.OwnerID,
	)
	return i, err
}

const deleteFriendGroup = `-- name: DeleteFriendGroup :exec
DELETE FROM friend_groups
WHERE id = $1
`

func (q *Queries) DeleteFriendGroup(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteFriendGroup, id)
	return err
}

const getDeviceTokens = `-- name: GetDeviceTokens :many
SELECT device_tokens FROM users
JOIN friend_group_members ON friend_group_members.user_id = users.id
WHERE friend_group_members.group_id IN ($1::uuid[])
`

func (q *Queries) GetDeviceTokens(ctx context.Context, dollar_1 []uuid.UUID) ([][]string, error) {
	rows, err := q.db.Query(ctx, getDeviceTokens, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items [][]string
	for rows.Next() {
		var device_tokens []string
		if err := rows.Scan(&device_tokens); err != nil {
			return nil, err
		}
		items = append(items, device_tokens)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFriendGroup = `-- name: GetFriendGroup :one
SELECT
    id,
    name,
    date_created,
    owner_id
FROM friend_groups
WHERE id = $1
`

func (q *Queries) GetFriendGroup(ctx context.Context, id uuid.UUID) (FriendGroup, error) {
	row := q.db.QueryRow(ctx, getFriendGroup, id)
	var i FriendGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DateCreated,
		&i.OwnerID,
	)
	return i, err
}

const getFriendGroupsByIDs = `-- name: GetFriendGroupsByIDs :many
SELECT
    id,
    name,
    date_created,
    owner_id
FROM friend_groups
WHERE id = ANY($1::uuid[])
ORDER BY name
`

func (q *Queries) GetFriendGroupsByIDs(ctx context.Context, dollar_1 []uuid.UUID) ([]FriendGroup, error) {
	rows, err := q.db.Query(ctx, getFriendGroupsByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FriendGroup
	for rows.Next() {
		var i FriendGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DateCreated,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFriendGroups = `-- name: ListFriendGroups :many
SELECT
    id,
    name,
    date_created,
    owner_id
FROM friend_groups
`

func (q *Queries) ListFriendGroups(ctx context.Context) ([]FriendGroup, error) {
	rows, err := q.db.Query(ctx, listFriendGroups)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FriendGroup
	for rows.Next() {
		var i FriendGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.DateCreated,
			&i.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupMembers = `-- name: ListGroupMembers :many
SELECT
    group_id,
    user_id,
    joined_at,
    role
FROM friend_group_members
WHERE group_id = $1
`

func (q *Queries) ListGroupMembers(ctx context.Context, groupID uuid.UUID) ([]FriendGroupMember, error) {
	rows, err := q.db.Query(ctx, listGroupMembers, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FriendGroupMember
	for rows.Next() {
		var i FriendGroupMember
		if err := rows.Scan(
			&i.GroupID,
			&i.UserID,
			&i.JoinedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupMembersWithProfiles = `-- name: ListGroupMembersWithProfiles :many
SELECT friend_group_members.group_id, friend_group_members.user_id, friend_group_members.joined_at, friend_group_members.role, user_profiles.user_id, user_profiles.profile_pic, user_profiles.username, user_profiles.name
FROM friend_group_members
JOIN user_profiles ON user_profiles.user_id = friend_group_members.user_id
WHERE friend_group_members.group_id = $1
ORDER BY user_profiles.username
`

type ListGroupMembersWithProfilesRow struct {
	FriendGroupMember FriendGroupMember `json:"friendGroupMember"`
	UserProfile       UserProfile       `json:"userProfile"`
}

func (q *Queries) ListGroupMembersWithProfiles(ctx context.Context, groupID uuid.UUID) ([]ListGroupMembersWithProfilesRow, error) {
	rows, err := q.db.Query(ctx, listGroupMembersWithProfiles, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListGroupMembersWithProfilesRow
	for rows.Next() {
		var i ListGroupMembersWithProfilesRow
		if err := rows.Scan(
			&i.FriendGroupMember.GroupID,
			&i.FriendGroupMember.UserID,
			&i.FriendGroupMember.JoinedAt,
			&i.FriendGroupMember.Role,
			&i.UserProfile.UserID,
			&i.UserProfile.ProfilePic,
			&i.UserProfile.Username,
			&i.UserProfile.Name,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUserGroups = `-- name: ListUserGroups :many
SELECT friend_groups.id, friend_groups.name, friend_groups.date_created, friend_groups.owner_id
FROM friend_group_members
JOIN friend_groups ON friend_group_members.group_id = friend_groups.id
WHERE friend_group_members.user_id = $1
`

type ListUserGroupsRow struct {
	FriendGroup FriendGroup `json:"friendGroup"`
}

func (q *Queries) ListUserGroups(ctx context.Context, userID uuid.UUID) ([]ListUserGroupsRow, error) {
	rows, err := q.db.Query(ctx, listUserGroups, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserGroupsRow
	for rows.Next() {
		var i ListUserGroupsRow
		if err := rows.Scan(
			&i.FriendGroup.ID,
			&i.FriendGroup.Name,
			&i.FriendGroup.DateCreated,
			&i.FriendGroup.OwnerID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromGroup = `-- name: RemoveUserFromGroup :exec
DELETE FROM friend_group_members
WHERE group_id = $1
  AND user_id = $2
`

type RemoveUserFromGroupParams struct {
	GroupID uuid.UUID `json:"groupId"`
	UserID  uuid.UUID `json:"userId"`
}

func (q *Queries) RemoveUserFromGroup(ctx context.Context, arg RemoveUserFromGroupParams) error {
	_, err := q.db.Exec(ctx, removeUserFromGroup, arg.GroupID, arg.UserID)
	return err
}

const updateFriendGroupName = `-- name: UpdateFriendGroupName :one
UPDATE friend_groups
SET name = $2
WHERE id = $1
RETURNING id, name, date_created, owner_id
`

type UpdateFriendGroupNameParams struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) UpdateFriendGroupName(ctx context.Context, arg UpdateFriendGroupNameParams) (FriendGroup, error) {
	row := q.db.QueryRow(ctx, updateFriendGroupName, arg.ID, arg.Name)
	var i FriendGroup
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.DateCreated,
		&i.OwnerID,
	)
	return i, err
}
